"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCloudEndpoints = void 0;
const express_1 = require("express");
const zlib_1 = require("zlib");
const types_1 = require("../../types");
const metadata_1 = require("../metadata");
const registry_1 = require("../../registry");
const emulatorLogger_1 = require("../../emulatorLogger");
const crc_1 = require("../crc");
const multipart_1 = require("../multipart");
const upload_1 = require("../upload");
const errors_1 = require("../errors");
const request_1 = require("../../shared/request");
function createCloudEndpoints(emulator) {
    const gcloudStorageAPI = (0, express_1.Router)();
    const { adminStorageLayer, uploadService } = emulator;
    gcloudStorageAPI.use(/.*\/b\/(.+?)\/.*/, (req, res, next) => {
        adminStorageLayer.createBucket(req.params[0]);
        next();
    });
    gcloudStorageAPI.get("/b", async (req, res) => {
        res.json({
            kind: "storage#buckets",
            items: await adminStorageLayer.listBuckets(),
        });
    });
    gcloudStorageAPI.get(["/b/:bucketId/o/:objectId", "/download/storage/v1/b/:bucketId/o/:objectId"], async (req, res) => {
        let getObjectResponse;
        try {
            getObjectResponse = await adminStorageLayer.getObject({
                bucketId: req.params.bucketId,
                decodedObjectId: req.params.objectId,
            });
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return sendObjectNotFound(req, res);
            }
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        if (req.query.alt === "media") {
            return sendFileBytes(getObjectResponse.metadata, getObjectResponse.data, req, res);
        }
        return res.json(new metadata_1.CloudStorageObjectMetadata(getObjectResponse.metadata));
    });
    gcloudStorageAPI.patch("/b/:bucketId/o/:objectId", async (req, res) => {
        let updatedMetadata;
        try {
            updatedMetadata = await adminStorageLayer.updateObjectMetadata({
                bucketId: req.params.bucketId,
                decodedObjectId: req.params.objectId,
                metadata: req.body,
            });
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return sendObjectNotFound(req, res);
            }
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        return res.json(new metadata_1.CloudStorageObjectMetadata(updatedMetadata));
    });
    gcloudStorageAPI.get("/b/:bucketId/o", async (req, res) => {
        var _a;
        let listResponse;
        try {
            listResponse = await adminStorageLayer.listObjects({
                bucketId: req.params.bucketId,
                prefix: req.query.prefix ? req.query.prefix.toString() : "",
                delimiter: req.query.delimiter ? req.query.delimiter.toString() : "",
                pageToken: req.query.pageToken ? req.query.pageToken.toString() : undefined,
                maxResults: req.query.maxResults ? +req.query.maxResults.toString() : undefined,
                authorization: req.header("authorization"),
            });
        }
        catch (err) {
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        return res.status(200).json({
            kind: "#storage/objects",
            nextPageToken: listResponse.nextPageToken,
            prefixes: listResponse.prefixes,
            items: (_a = listResponse.items) === null || _a === void 0 ? void 0 : _a.map((item) => new metadata_1.CloudStorageObjectMetadata(item)),
        });
    });
    gcloudStorageAPI.delete("/b/:bucketId/o/:objectId", async (req, res) => {
        try {
            await adminStorageLayer.deleteObject({
                bucketId: req.params.bucketId,
                decodedObjectId: req.params.objectId,
            });
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return sendObjectNotFound(req, res);
            }
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        return res.sendStatus(204);
    });
    gcloudStorageAPI.put("/upload/storage/v1/b/:bucketId/o", async (req, res) => {
        if (!req.query.upload_id) {
            res.sendStatus(400);
            return;
        }
        const uploadId = req.query.upload_id.toString();
        let upload;
        try {
            uploadService.continueResumableUpload(uploadId, await (0, request_1.reqBodyToBuffer)(req));
            upload = uploadService.finalizeResumableUpload(uploadId);
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return res.sendStatus(404);
            }
            else if (err instanceof upload_1.UploadNotActiveError) {
                return res.sendStatus(400);
            }
            throw err;
        }
        let metadata;
        try {
            metadata = await adminStorageLayer.uploadObject(upload);
        }
        catch (err) {
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        return res.json(new metadata_1.CloudStorageObjectMetadata(metadata));
    });
    gcloudStorageAPI.post("/b/:bucketId/o/:objectId/acl", async (req, res) => {
        var _a, _b;
        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.STORAGE).log("WARN_ONCE", "Cloud Storage ACLs are not supported in the Storage Emulator. All related methods will succeed, but have no effect.");
        let getObjectResponse;
        try {
            getObjectResponse = await adminStorageLayer.getObject({
                bucketId: req.params.bucketId,
                decodedObjectId: req.params.objectId,
            });
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return sendObjectNotFound(req, res);
            }
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        const { metadata } = getObjectResponse;
        metadata.update({});
        return res.json({
            kind: "storage#objectAccessControl",
            object: metadata.name,
            id: `${req.params.bucketId}/${metadata.name}/${metadata.generation}/allUsers`,
            selfLink: `http://${(_a = registry_1.EmulatorRegistry.getInfo(types_1.Emulators.STORAGE)) === null || _a === void 0 ? void 0 : _a.host}:${(_b = registry_1.EmulatorRegistry.getInfo(types_1.Emulators.STORAGE)) === null || _b === void 0 ? void 0 : _b.port}/storage/v1/b/${metadata.bucket}/o/${encodeURIComponent(metadata.name)}/acl/allUsers`,
            bucket: metadata.bucket,
            entity: req.body.entity,
            role: req.body.role,
            etag: "someEtag",
            generation: metadata.generation.toString(),
        });
    });
    gcloudStorageAPI.post("/upload/storage/v1/b/:bucketId/o", async (req, res) => {
        if (!req.query.name) {
            res.sendStatus(400);
            return;
        }
        let name = req.query.name.toString();
        if (name.startsWith("/")) {
            name = name.slice(1);
        }
        const contentTypeHeader = req.header("content-type") || req.header("x-upload-content-type");
        if (!contentTypeHeader) {
            return res.sendStatus(400);
        }
        if (req.query.uploadType === "resumable") {
            const emulatorInfo = registry_1.EmulatorRegistry.getInfo(types_1.Emulators.STORAGE);
            if (emulatorInfo === undefined) {
                return res.sendStatus(500);
            }
            const upload = uploadService.startResumableUpload({
                bucketId: req.params.bucketId,
                objectId: name,
                metadataRaw: JSON.stringify(req.body),
                authorization: req.header("authorization"),
            });
            const uploadUrl = registry_1.EmulatorRegistry.url(types_1.Emulators.STORAGE, req);
            uploadUrl.pathname = `/upload/storage/v1/b/${req.params.bucketId}/o`;
            uploadUrl.searchParams.set("name", name);
            uploadUrl.searchParams.set("uploadType", "resumable");
            uploadUrl.searchParams.set("upload_id", upload.id);
            return res.header("location", uploadUrl.toString()).sendStatus(200);
        }
        let metadataRaw;
        let dataRaw;
        try {
            ({ metadataRaw, dataRaw } = (0, multipart_1.parseObjectUploadMultipartRequest)(contentTypeHeader, await (0, request_1.reqBodyToBuffer)(req)));
        }
        catch (err) {
            if (err instanceof Error) {
                return res.status(400).json({
                    error: {
                        code: 400,
                        message: err.message,
                    },
                });
            }
            throw err;
        }
        const upload = uploadService.multipartUpload({
            bucketId: req.params.bucketId,
            objectId: name,
            metadataRaw: metadataRaw,
            dataRaw: dataRaw,
            authorization: req.header("authorization"),
        });
        let metadata;
        try {
            metadata = await adminStorageLayer.uploadObject(upload);
        }
        catch (err) {
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        return res.status(200).json(new metadata_1.CloudStorageObjectMetadata(metadata));
    });
    gcloudStorageAPI.get("/:bucketId/:objectId(**)", async (req, res) => {
        let getObjectResponse;
        try {
            getObjectResponse = await adminStorageLayer.getObject({
                bucketId: req.params.bucketId,
                decodedObjectId: req.params.objectId,
            });
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return sendObjectNotFound(req, res);
            }
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        return sendFileBytes(getObjectResponse.metadata, getObjectResponse.data, req, res);
    });
    gcloudStorageAPI.post("/b/:bucketId/o/:objectId/:method(rewriteTo|copyTo)/b/:destBucketId/o/:destObjectId", (req, res, next) => {
        if (req.params.method === "rewriteTo" && req.query.rewriteToken) {
            return next();
        }
        let metadata;
        try {
            metadata = adminStorageLayer.copyObject({
                sourceBucket: req.params.bucketId,
                sourceObject: req.params.objectId,
                destinationBucket: req.params.destBucketId,
                destinationObject: req.params.destObjectId,
                incomingMetadata: req.body,
                authorization: "Bearer owner",
            });
        }
        catch (err) {
            if (err instanceof errors_1.NotFoundError) {
                return sendObjectNotFound(req, res);
            }
            if (err instanceof errors_1.ForbiddenError) {
                return res.sendStatus(403);
            }
            throw err;
        }
        const resource = new metadata_1.CloudStorageObjectMetadata(metadata);
        res.status(200);
        if (req.params.method === "copyTo") {
            return res.json(resource);
        }
        else if (req.params.method === "rewriteTo") {
            return res.json({
                kind: "storage#rewriteResponse",
                totalBytesRewritten: String(metadata.size),
                objectSize: String(metadata.size),
                done: true,
                resource,
            });
        }
        else {
            return next();
        }
    });
    gcloudStorageAPI.all("/**", (req, res) => {
        if (process.env.STORAGE_EMULATOR_DEBUG) {
            console.table(req.headers);
            console.log(req.method, req.url);
            res.status(501).json("endpoint not implemented");
        }
        else {
            res.sendStatus(501);
        }
    });
    return gcloudStorageAPI;
}
exports.createCloudEndpoints = createCloudEndpoints;
function sendFileBytes(md, data, req, res) {
    const isGZipped = md.contentEncoding === "gzip";
    if (isGZipped) {
        data = (0, zlib_1.gunzipSync)(data);
    }
    res.setHeader("Accept-Ranges", "bytes");
    res.setHeader("Content-Type", md.contentType);
    res.setHeader("Content-Disposition", md.contentDisposition);
    res.setHeader("Content-Encoding", md.contentEncoding);
    res.setHeader("ETag", md.etag);
    res.setHeader("Cache-Control", md.cacheControl);
    res.setHeader("x-goog-generation", `${md.generation}`);
    res.setHeader("x-goog-metadatageneration", `${md.metageneration}`);
    res.setHeader("x-goog-storage-class", md.storageClass);
    res.setHeader("x-goog-hash", `crc32c=${(0, crc_1.crc32cToString)(md.crc32c)},md5=${md.md5Hash}`);
    const byteRange = req.range(data.byteLength, { combine: true });
    if (Array.isArray(byteRange) && byteRange.type === "bytes" && byteRange.length > 0) {
        const range = byteRange[0];
        res.setHeader("Content-Range", `${byteRange.type} ${range.start}-${range.end}/${data.byteLength}`);
        res.status(206).end(data.slice(range.start, range.end + 1));
    }
    else {
        res.end(data);
    }
}
function sendObjectNotFound(req, res) {
    res.status(404);
    const message = `No such object: ${req.params.bucketId}/${req.params.objectId}`;
    if (req.method === "GET" && req.query.alt === "media") {
        res.send(message);
    }
    else {
        res.json({
            error: {
                code: 404,
                message,
                errors: [
                    {
                        message,
                        domain: "global",
                        reason: "notFound",
                    },
                ],
            },
        });
    }
}
